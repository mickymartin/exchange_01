<?php

namespace ccxtpro;

// PLEASE DO NOT EDIT THIS FILE, IT IS GENERATED AND WILL BE OVERWRITTEN:
// https://github.com/ccxt/ccxt/blob/master/CONTRIBUTING.md#how-to-contribute-code

use Exception; // a common import
use \ccxt\ExchangeError;
use \ccxt\NotSupported;

class bitmex extends \ccxt\bitmex {

    use ClientTrait;

    public function describe() {
        return $this->deep_extend(parent::describe (), array(
            'has' => array(
                'ws' => true,
                'watchTicker' => true,
                'watchTickers' => false,
                'watchTrades' => true,
                'watchOrderBook' => true,
                'watchOHLCV' => true,
            ),
            'urls' => array(
                'api' => array(
                    'ws' => 'wss://www.bitmex.com/realtime',
                ),
            ),
            'versions' => array(
                'ws' => '0.2.0',
            ),
            'options' => array(
                'watchOrderBookLevel' => 'orderBookL2', // 'orderBookL2' = L2 full order book, 'orderBookL2_25' = L2 top 25, 'orderBook10' L3 top 10
                'tradesLimit' => 1000,
                'OHLCVLimit' => 1000,
            ),
            'exceptions' => array(
                'ws' => array(
                    'exact' => array(
                    ),
                    'broad' => array(
                        'Rate limit exceeded' => '\\ccxt\\RateLimitExceeded',
                    ),
                ),
            ),
        ));
    }

    public function watch_ticker($symbol, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $name = 'instrument';
        $messageHash = $name . ':' . $market['id'];
        $url = $this->urls['api']['ws'];
        $request = array(
            'op' => 'subscribe',
            'args' => array(
                $messageHash,
            ),
        );
        return $this->watch($url, $messageHash, array_merge($request, $params), $messageHash);
    }

    public function handle_ticker($client, $message) {
        //
        //     {
        //         $table => 'instrument',
        //         action => 'partial',
        //         keys => array( 'symbol' ),
        //         types => array(
        //             $symbol => 'symbol',
        //             rootSymbol => 'symbol',
        //             state => 'symbol',
        //             typ => 'symbol',
        //             listing => 'timestamp',
        //             front => 'timestamp',
        //             expiry => 'timestamp',
        //             settle => 'timestamp',
        //             relistInterval => 'timespan',
        //             inverseLeg => 'symbol',
        //             sellLeg => 'symbol',
        //             buyLeg => 'symbol',
        //             optionStrikePcnt => 'float',
        //             optionStrikeRound => 'float',
        //             optionStrikePrice => 'float',
        //             optionMultiplier => 'float',
        //             positionCurrency => 'symbol',
        //             underlying => 'symbol',
        //             quoteCurrency => 'symbol',
        //             underlyingSymbol => 'symbol',
        //             reference => 'symbol',
        //             referenceSymbol => 'symbol',
        //             calcInterval => 'timespan',
        //             publishInterval => 'timespan',
        //             publishTime => 'timespan',
        //             maxOrderQty => 'long',
        //             maxPrice => 'float',
        //             lotSize => 'long',
        //             tickSize => 'float',
        //             multiplier => 'long',
        //             settlCurrency => 'symbol',
        //             underlyingToPositionMultiplier => 'long',
        //             underlyingToSettleMultiplier => 'long',
        //             quoteToSettleMultiplier => 'long',
        //             isQuanto => 'boolean',
        //             isInverse => 'boolean',
        //             initMargin => 'float',
        //             maintMargin => 'float',
        //             riskLimit => 'long',
        //             riskStep => 'long',
        //             limit => 'float',
        //             capped => 'boolean',
        //             taxed => 'boolean',
        //             deleverage => 'boolean',
        //             makerFee => 'float',
        //             takerFee => 'float',
        //             settlementFee => 'float',
        //             insuranceFee => 'float',
        //             fundingBaseSymbol => 'symbol',
        //             fundingQuoteSymbol => 'symbol',
        //             fundingPremiumSymbol => 'symbol',
        //             fundingTimestamp => 'timestamp',
        //             fundingInterval => 'timespan',
        //             fundingRate => 'float',
        //             indicativeFundingRate => 'float',
        //             rebalanceTimestamp => 'timestamp',
        //             rebalanceInterval => 'timespan',
        //             openingTimestamp => 'timestamp',
        //             closingTimestamp => 'timestamp',
        //             sessionInterval => 'timespan',
        //             prevClosePrice => 'float',
        //             limitDownPrice => 'float',
        //             limitUpPrice => 'float',
        //             bankruptLimitDownPrice => 'float',
        //             bankruptLimitUpPrice => 'float',
        //             prevTotalVolume => 'long',
        //             totalVolume => 'long',
        //             volume => 'long',
        //             volume24h => 'long',
        //             prevTotalTurnover => 'long',
        //             totalTurnover => 'long',
        //             turnover => 'long',
        //             turnover24h => 'long',
        //             homeNotional24h => 'float',
        //             foreignNotional24h => 'float',
        //             prevPrice24h => 'float',
        //             vwap => 'float',
        //             highPrice => 'float',
        //             lowPrice => 'float',
        //             lastPrice => 'float',
        //             lastPriceProtected => 'float',
        //             lastTickDirection => 'symbol',
        //             lastChangePcnt => 'float',
        //             bidPrice => 'float',
        //             midPrice => 'float',
        //             askPrice => 'float',
        //             impactBidPrice => 'float',
        //             impactMidPrice => 'float',
        //             impactAskPrice => 'float',
        //             hasLiquidity => 'boolean',
        //             openInterest => 'long',
        //             openValue => 'long',
        //             fairMethod => 'symbol',
        //             fairBasisRate => 'float',
        //             fairBasis => 'float',
        //             fairPrice => 'float',
        //             markMethod => 'symbol',
        //             markPrice => 'float',
        //             indicativeTaxRate => 'float',
        //             indicativeSettlePrice => 'float',
        //             optionUnderlyingPrice => 'float',
        //             settledPrice => 'float',
        //             timestamp => 'timestamp'
        //         ),
        //         foreignKeys => array(
        //             inverseLeg => 'instrument',
        //             sellLeg => 'instrument',
        //             buyLeg => 'instrument'
        //         ),
        //         attributes => array( $symbol => 'unique' ),
        //         filter => array( $symbol => 'XBTUSD' ),
        //         $data => array(
        //             {
        //                 $symbol => 'XBTUSD',
        //                 rootSymbol => 'XBT',
        //                 state => 'Open',
        //                 typ => 'FFWCSX',
        //                 listing => '2016-05-13T12:00:00.000Z',
        //                 front => '2016-05-13T12:00:00.000Z',
        //                 expiry => null,
        //                 settle => null,
        //                 relistInterval => null,
        //                 inverseLeg => '',
        //                 sellLeg => '',
        //                 buyLeg => '',
        //                 optionStrikePcnt => null,
        //                 optionStrikeRound => null,
        //                 optionStrikePrice => null,
        //                 optionMultiplier => null,
        //                 positionCurrency => 'USD',
        //                 underlying => 'XBT',
        //                 quoteCurrency => 'USD',
        //                 underlyingSymbol => 'XBT=',
        //                 reference => 'BMEX',
        //                 referenceSymbol => '.BXBT',
        //                 calcInterval => null,
        //                 publishInterval => null,
        //                 publishTime => null,
        //                 maxOrderQty => 10000000,
        //                 maxPrice => 1000000,
        //                 lotSize => 1,
        //                 tickSize => 0.5,
        //                 multiplier => -100000000,
        //                 settlCurrency => 'XBt',
        //                 underlyingToPositionMultiplier => null,
        //                 underlyingToSettleMultiplier => -100000000,
        //                 quoteToSettleMultiplier => null,
        //                 isQuanto => false,
        //                 isInverse => true,
        //                 initMargin => 0.01,
        //                 maintMargin => 0.005,
        //                 riskLimit => 20000000000,
        //                 riskStep => 10000000000,
        //                 limit => null,
        //                 capped => false,
        //                 taxed => true,
        //                 deleverage => true,
        //                 makerFee => -0.00025,
        //                 takerFee => 0.00075,
        //                 settlementFee => 0,
        //                 insuranceFee => 0,
        //                 fundingBaseSymbol => '.XBTBON8H',
        //                 fundingQuoteSymbol => '.USDBON8H',
        //                 fundingPremiumSymbol => '.XBTUSDPI8H',
        //                 fundingTimestamp => '2020-01-29T12:00:00.000Z',
        //                 fundingInterval => '2000-01-01T08:00:00.000Z',
        //                 fundingRate => 0.000597,
        //                 indicativeFundingRate => 0.000652,
        //                 rebalanceTimestamp => null,
        //                 rebalanceInterval => null,
        //                 openingTimestamp => '2020-01-29T11:00:00.000Z',
        //                 closingTimestamp => '2020-01-29T12:00:00.000Z',
        //                 sessionInterval => '2000-01-01T01:00:00.000Z',
        //                 prevClosePrice => 9063.96,
        //                 limitDownPrice => null,
        //                 limitUpPrice => null,
        //                 bankruptLimitDownPrice => null,
        //                 bankruptLimitUpPrice => null,
        //                 prevTotalVolume => 1989881049026,
        //                 totalVolume => 1990196740950,
        //                 volume => 315691924,
        //                 volume24h => 4491824765,
        //                 prevTotalTurnover => 27865497128425564,
        //                 totalTurnover => 27868891594857150,
        //                 turnover => 3394466431587,
        //                 turnover24h => 48863390064843,
        //                 homeNotional24h => 488633.9006484273,
        //                 foreignNotional24h => 4491824765,
        //                 prevPrice24h => 9091,
        //                 vwap => 9192.8663,
        //                 highPrice => 9440,
        //                 lowPrice => 8886,
        //                 lastPrice => 9287,
        //                 lastPriceProtected => 9287,
        //                 lastTickDirection => 'PlusTick',
        //                 lastChangePcnt => 0.0216,
        //                 bidPrice => 9286,
        //                 midPrice => 9286.25,
        //                 askPrice => 9286.5,
        //                 impactBidPrice => 9285.9133,
        //                 impactMidPrice => 9286.75,
        //                 impactAskPrice => 9287.6382,
        //                 hasLiquidity => true,
        //                 openInterest => 967826984,
        //                 openValue => 10432207060536,
        //                 fairMethod => 'FundingRate',
        //                 fairBasisRate => 0.6537149999999999,
        //                 fairBasis => 0.33,
        //                 fairPrice => 9277.2,
        //                 markMethod => 'FairPrice',
        //                 markPrice => 9277.2,
        //                 indicativeTaxRate => 0,
        //                 indicativeSettlePrice => 9276.87,
        //                 optionUnderlyingPrice => null,
        //                 settledPrice => null,
        //                 timestamp => '2020-01-29T11:31:37.114Z'
        //             }
        //         )
        //     }
        //
        $table = $this->safe_string($message, 'table');
        $data = $this->safe_value($message, 'data', array());
        for ($i = 0; $i < count($data); $i++) {
            $update = $data[$i];
            $marketId = $this->safe_value($update, 'symbol');
            if (is_array($this->markets_by_id) && array_key_exists($marketId, $this->markets_by_id)) {
                $market = $this->markets_by_id[$marketId];
                $symbol = $market['symbol'];
                $messageHash = $table . ':' . $marketId;
                $ticker = $this->safe_value($this->tickers, $symbol, array());
                $info = $this->safe_value($ticker, 'info', array());
                $ticker = $this->parse_ticker(array_merge($info, $update), $market);
                $this->tickers[$symbol] = $ticker;
                $client->resolve ($ticker, $messageHash);
            }
        }
        return $message;
    }

    public function watch_balance($params = array ()) {
        $this->load_markets();
        throw new NotSupported($this->id . ' watchBalance() not implemented yet');
    }

    public function handle_trades($client, $message) {
        //
        // initial snapshot
        //
        //     {
        //         $table => 'trade',
        //         action => 'partial',
        //         keys => array(),
        //         types => array(
        //             timestamp => 'timestamp',
        //             $symbol => 'symbol',
        //             side => 'symbol',
        //             size => 'long',
        //             price => 'float',
        //             tickDirection => 'symbol',
        //             trdMatchID => 'guid',
        //             grossValue => 'long',
        //             homeNotional => 'float',
        //             foreignNotional => 'float'
        //         ),
        //         foreignKeys => array( $symbol => 'instrument', side => 'side' ),
        //         attributes => array( timestamp => 'sorted', $symbol => 'grouped' ),
        //         filter => array( $symbol => 'XBTUSD' ),
        //         $data => array(
        //             {
        //                 timestamp => '2020-01-30T17:03:07.854Z',
        //                 $symbol => 'XBTUSD',
        //                 side => 'Buy',
        //                 size => 15000,
        //                 price => 9378,
        //                 tickDirection => 'ZeroPlusTick',
        //                 trdMatchID => '5b426e7f-83d1-2c80-295d-ee995b8ceb4a',
        //                 grossValue => 159945000,
        //                 homeNotional => 1.59945,
        //                 foreignNotional => 15000
        //             }
        //         )
        //     }
        //
        // updates
        //
        //     {
        //         $table => 'trade',
        //         action => 'insert',
        //         $data => array(
        //             {
        //                 timestamp => '2020-01-30T17:31:40.160Z',
        //                 $symbol => 'XBTUSD',
        //                 side => 'Sell',
        //                 size => 37412,
        //                 price => 9521.5,
        //                 tickDirection => 'ZeroMinusTick',
        //                 trdMatchID => 'a4bfc6bc-6cf1-1a11-622e-270eef8ca5c7',
        //                 grossValue => 392938236,
        //                 homeNotional => 3.92938236,
        //                 foreignNotional => 37412
        //             }
        //         )
        //     }
        //
        $table = 'trade';
        $data = $this->safe_value($message, 'data', array());
        $dataByMarketIds = $this->group_by($data, 'symbol');
        $marketIds = is_array($dataByMarketIds) ? array_keys($dataByMarketIds) : array();
        for ($i = 0; $i < count($marketIds); $i++) {
            $marketId = $marketIds[$i];
            if (is_array($this->markets_by_id) && array_key_exists($marketId, $this->markets_by_id)) {
                $market = $this->markets_by_id[$marketId];
                $messageHash = $table . ':' . $marketId;
                $symbol = $market['symbol'];
                $trades = $this->parse_trades($dataByMarketIds[$marketId], $market);
                $stored = $this->safe_value($this->trades, $symbol);
                if ($stored === null) {
                    $limit = $this->safe_integer($this->options, 'tradesLimit', 1000);
                    $stored = new ArrayCache ($limit);
                    $this->trades[$symbol] = $stored;
                }
                for ($j = 0; $j < count($trades); $j++) {
                    $stored->append ($trades[$j]);
                }
                $client->resolve ($stored, $messageHash);
            }
        }
    }

    public function watch_trades($symbol, $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $table = 'trade';
        $messageHash = $table . ':' . $market['id'];
        $url = $this->urls['api']['ws'];
        $request = array(
            'op' => 'subscribe',
            'args' => array(
                $messageHash,
            ),
        );
        $future = $this->watch($url, $messageHash, array_merge($request, $params), $messageHash);
        return $this->after($future, array($this, 'filter_by_since_limit'), $since, $limit, 'timestamp', true);
    }

    public function watch_order_book($symbol, $limit = null, $params = array ()) {
        $table = null;
        if ($limit === null) {
            $table = $this->safe_string($this->options, 'watchOrderBookLevel', 'orderBookL2');
        } else if ($limit === 25) {
            $table = 'orderBookL2_25';
        } else if ($limit === 10) {
            $table = 'orderBookL10';
        } else {
            throw new ExchangeError($this->id . ' watchOrderBook $limit argument must be null (L2), 25 (L2) or 10 (L3)');
        }
        $this->load_markets();
        $market = $this->market($symbol);
        $messageHash = $table . ':' . $market['id'];
        $url = $this->urls['api']['ws'];
        $request = array(
            'op' => 'subscribe',
            'args' => array(
                $messageHash,
            ),
        );
        $future = $this->watch($url, $messageHash, $this->deep_extend($request, $params), $messageHash);
        return $this->after($future, array($this, 'limit_order_book'), $symbol, $limit, $params);
    }

    public function watch_ohlcv($symbol, $timeframe = '1m', $since = null, $limit = null, $params = array ()) {
        $this->load_markets();
        $market = $this->market($symbol);
        $table = 'tradeBin' . $this->timeframes[$timeframe];
        $messageHash = $table . ':' . $market['id'];
        $url = $this->urls['api']['ws'];
        $request = array(
            'op' => 'subscribe',
            'args' => array(
                $messageHash,
            ),
        );
        $future = $this->watch($url, $messageHash, array_merge($request, $params), $messageHash);
        return $this->after($future, array($this, 'filter_by_since_limit'), $since, $limit, 0, true);
    }

    public function find_timeframe($timeframe) {
        $keys = is_array($this->timeframes) ? array_keys($this->timeframes) : array();
        for ($i = 0; $i < count($keys); $i++) {
            $key = $keys[$i];
            if ($this->timeframes[$key] === $timeframe) {
                return $key;
            }
        }
        return null;
    }

    public function handle_ohlcv($client, $message) {
        //
        //     {
        //         $table => 'tradeBin1m',
        //         action => 'partial',
        //         keys => array(),
        //         types => array(
        //             timestamp => 'timestamp',
        //             $symbol => 'symbol',
        //             open => 'float',
        //             high => 'float',
        //             low => 'float',
        //             close => 'float',
        //             trades => 'long',
        //             volume => 'long',
        //             vwap => 'float',
        //             lastSize => 'long',
        //             turnover => 'long',
        //             homeNotional => 'float',
        //             foreignNotional => 'float'
        //         ),
        //         foreignKeys => array( $symbol => 'instrument' ),
        //         attributes => array( timestamp => 'sorted', $symbol => 'grouped' ),
        //         filter => array( $symbol => 'XBTUSD' ),
        //         data => array(
        //             {
        //                 timestamp => '2020-02-03T01:13:00.000Z',
        //                 $symbol => 'XBTUSD',
        //                 open => 9395,
        //                 high => 9395.5,
        //                 low => 9394.5,
        //                 close => 9395,
        //                 trades => 221,
        //                 volume => 839204,
        //                 vwap => 9394.9643,
        //                 lastSize => 1874,
        //                 turnover => 8932641535,
        //                 homeNotional => 89.32641534999999,
        //                 foreignNotional => 839204
        //             }
        //         )
        //     }
        //
        //
        //     {
        //         $table => 'tradeBin1m',
        //         action => 'insert',
        //         data => array(
        //             {
        //                 timestamp => '2020-02-03T18:28:00.000Z',
        //                 $symbol => 'XBTUSD',
        //                 open => 9256,
        //                 high => 9256.5,
        //                 low => 9256,
        //                 close => 9256,
        //                 trades => 29,
        //                 volume => 79057,
        //                 vwap => 9256.688,
        //                 lastSize => 100,
        //                 turnover => 854077082,
        //                 homeNotional => 8.540770820000002,
        //                 foreignNotional => 79057
        //             }
        //         )
        //     }
        //
        // --------------------------------------------------------------------
        $table = $this->safe_string($message, 'table');
        $interval = str_replace('tradeBin', '', $table);
        $timeframe = $this->find_timeframe($interval);
        $duration = $this->parse_timeframe($timeframe);
        $candles = $this->safe_value($message, 'data', array());
        $results = array();
        for ($i = 0; $i < count($candles); $i++) {
            $candle = $candles[$i];
            $marketId = $this->safe_string($candle, 'symbol');
            if (is_array($this->markets_by_id) && array_key_exists($marketId, $this->markets_by_id)) {
                $market = $this->markets_by_id[$marketId];
                $symbol = $market['symbol'];
                $messageHash = $table . ':' . $market['id'];
                $result = array(
                    $this->parse8601($this->safe_string($candle, 'timestamp')) - $duration * 1000,
                    $this->safe_float($candle, 'open'),
                    $this->safe_float($candle, 'high'),
                    $this->safe_float($candle, 'low'),
                    $this->safe_float($candle, 'close'),
                    $this->safe_float($candle, 'volume'),
                );
                $this->ohlcvs[$symbol] = $this->safe_value($this->ohlcvs, $symbol, array());
                $stored = $this->safe_value($this->ohlcvs[$symbol], $timeframe);
                if ($stored === null) {
                    $limit = $this->safe_integer($this->options, 'OHLCVLimit', 1000);
                    $stored = new ArrayCache ($limit);
                    $this->ohlcvs[$symbol][$timeframe] = $stored;
                }
                $length = is_array($stored) ? count($stored) : 0;
                if ($length && $result[0] === $stored[$length - 1][0]) {
                    $stored[$length - 1] = $result;
                } else {
                    $stored->append ($result);
                }
                $results[$messageHash] = $stored;
            }
        }
        $messageHashes = is_array($results) ? array_keys($results) : array();
        for ($i = 0; $i < count($messageHashes); $i++) {
            $messageHash = $messageHashes[$i];
            $client->resolve ($results[$messageHash], $messageHash);
        }
    }

    public function watch_heartbeat($params = array ()) {
        $this->load_markets();
        $event = 'heartbeat';
        $url = $this->urls['api']['ws'];
        return $this->watch($url, $event);
    }

    public function sign_message($client, $messageHash, $message, $params = array ()) {
        // todo bitmex signMessage not implemented yet
        return $message;
    }

    public function handle_order_book($client, $message) {
        //
        // first snapshot
        //
        //     {
        //         $table => 'orderBookL2',
        //         $action => 'partial',
        //         keys => array( 'symbol', 'id', 'side' ),
        //         types => array(
        //             $symbol => 'symbol',
        //             $id => 'long',
        //             $side => 'symbol',
        //             $size => 'long',
        //             $price => 'float'
        //         ),
        //         foreignKeys => array( $symbol => 'instrument', $side => 'side' ),
        //         attributes => array( $symbol => 'parted', $id => 'sorted' ),
        //         $filter => array( $symbol => 'XBTUSD' ),
        //         $data => array(
        //             array( $symbol => 'XBTUSD', $id => 8700000100, $side => 'Sell', $size => 1, $price => 999999 ),
        //             array( $symbol => 'XBTUSD', $id => 8700000200, $side => 'Sell', $size => 3, $price => 999998 ),
        //             array( $symbol => 'XBTUSD', $id => 8716991250, $side => 'Sell', $size => 26, $price => 830087.5 ),
        //             array( $symbol => 'XBTUSD', $id => 8728701950, $side => 'Sell', $size => 1720, $price => 712980.5 ),
        //         )
        //     }
        //
        // subsequent updates
        //
        //     {
        //         $table => 'orderBookL2',
        //         $action => 'update',
        //         $data => array(
        //             array( $symbol => 'XBTUSD', $id => 8799285100, $side => 'Sell', $size => 70590 ),
        //             array( $symbol => 'XBTUSD', $id => 8799285550, $side => 'Sell', $size => 217652 ),
        //             array( $symbol => 'XBTUSD', $id => 8799288950, $side => 'Buy', $size => 47552 ),
        //             array( $symbol => 'XBTUSD', $id => 8799289250, $side => 'Buy', $size => 78217 ),
        //         )
        //     }
        //
        $action = $this->safe_string($message, 'action');
        $table = $this->safe_string($message, 'table');
        $data = $this->safe_value($message, 'data', array());
        // if it's an initial snapshot
        if ($action === 'partial') {
            $filter = $this->safe_value($message, 'filter', array());
            $marketId = $this->safe_value($filter, 'symbol');
            if (is_array($this->markets_by_id) && array_key_exists($marketId, $this->markets_by_id)) {
                $market = $this->markets_by_id[$marketId];
                $symbol = $market['symbol'];
                if ($table === 'orderBookL2') {
                    $this->orderbooks[$symbol] = $this->indexed_order_book();
                } else if ($table === 'orderBookL2_25') {
                    $this->orderbooks[$symbol] = $this->indexed_order_book(array(), 25);
                } else if ($table === 'orderBook10') {
                    $this->orderbooks[$symbol] = $this->indexed_order_book(array(), 10);
                }
                $orderbook = $this->orderbooks[$symbol];
                for ($i = 0; $i < count($data); $i++) {
                    $price = $this->safe_float($data[$i], 'price');
                    $size = $this->safe_float($data[$i], 'size');
                    $id = $this->safe_string($data[$i], 'id');
                    $side = $this->safe_string($data[$i], 'side');
                    $side = ($side === 'Buy') ? 'bids' : 'asks';
                    $bookside = $orderbook[$side];
                    $bookside->store ($price, $size, $id);
                }
                $messageHash = $table . ':' . $marketId;
                $client->resolve ($orderbook, $messageHash);
            }
        } else {
            $numUpdatesByMarketId = array();
            for ($i = 0; $i < count($data); $i++) {
                $marketId = $this->safe_value($data[$i], 'symbol');
                if (is_array($this->markets_by_id) && array_key_exists($marketId, $this->markets_by_id)) {
                    if (!(is_array($numUpdatesByMarketId) && array_key_exists($marketId, $numUpdatesByMarketId))) {
                        $numUpdatesByMarketId[$marketId] = 0;
                    }
                    $numUpdatesByMarketId[$marketId] = $this->sum($numUpdatesByMarketId, 1);
                    $market = $this->markets_by_id[$marketId];
                    $symbol = $market['symbol'];
                    $orderbook = $this->orderbooks[$symbol];
                    $price = $this->safe_float($data[$i], 'price');
                    $size = $this->safe_float($data[$i], 'size', 0);
                    $id = $this->safe_string($data[$i], 'id');
                    $side = $this->safe_string($data[$i], 'side');
                    $side = ($side === 'Buy') ? 'bids' : 'asks';
                    $bookside = $orderbook[$side];
                    $bookside->store ($price, $size, $id);
                }
            }
            $marketIds = is_array($numUpdatesByMarketId) ? array_keys($numUpdatesByMarketId) : array();
            for ($i = 0; $i < count($marketIds); $i++) {
                $marketId = $marketIds[$i];
                $messageHash = $table . ':' . $marketId;
                $market = $this->markets_by_id[$marketId];
                $symbol = $market['symbol'];
                $orderbook = $this->orderbooks[$symbol];
                $client->resolve ($orderbook, $messageHash);
            }
        }
    }

    public function handle_system_status($client, $message) {
        //
        // todo answer the question whether handleSystemStatus should be renamed
        // and unified as handleStatus for any usage pattern that
        // involves system status and maintenance updates
        //
        //     {
        //         info => 'Welcome to the BitMEX Realtime API.',
        //         version => '2019-11-22T00:24:37.000Z',
        //         timestamp => '2019-11-23T09:02:27.771Z',
        //         docs => 'https://www.bitmex.com/app/wsAPI',
        //         limit => array( remaining => 39 )
        //     }
        //
        return $message;
    }

    public function handle_subscription_status($client, $message) {
        //
        //     {
        //         success => true,
        //         subscribe => 'orderBookL2:XBTUSD',
        //         request => array( op => 'subscribe', args => array( 'orderBookL2:XBTUSD' ) )
        //     }
        //
        return $message;
    }

    public function handle_error_message($client, $message) {
        //
        // generic $error format
        //
        //     array( "$error" => errorMessage )
        //
        // examples
        //
        //     {
        //         "status" => 429,
        //         "$error" => "Rate limit exceeded, retry in 1 seconds.",
        //         "meta" => array( "retryAfter" => 1 ),
        //         "$request" => array( "op" => "subscribe", "$args" => "orderBook" ),
        //     }
        //
        //     array( "$error" => "Rate limit exceeded, retry in 29 seconds." )
        //
        $error = $this->safe_value($message, 'error');
        if ($error !== null) {
            $request = $this->safe_value($message, 'request', array());
            $args = $this->safe_string($request, 'args', array());
            $numArgs = is_array($args) ? count($args) : 0;
            if ($numArgs > 0) {
                $messageHash = $args[0];
                $broad = $this->exceptions['ws']['broad'];
                $broadKey = $this->find_broadly_matched_key($broad, $error);
                $exception = null;
                if ($broadKey === null) {
                    $exception = new ExchangeError ($error);
                } else {
                    $exception = new $broad[$broadKey] ($error);
                }
                $client->reject ($exception, $messageHash);
                return false;
            }
        }
        return true;
    }

    public function handle_message($client, $message) {
        //
        //     {
        //         info => 'Welcome to the BitMEX Realtime API.',
        //         version => '2019-11-22T00:24:37.000Z',
        //         timestamp => '2019-11-23T09:04:42.569Z',
        //         docs => 'https://www.bitmex.com/app/wsAPI',
        //         limit => array( remaining => 38 )
        //     }
        //
        //     {
        //         success => true,
        //         subscribe => 'orderBookL2:XBTUSD',
        //         request => array( op => 'subscribe', args => array( 'orderBookL2:XBTUSD' ) )
        //     }
        //
        //     {
        //         $table => 'orderBookL2',
        //         action => 'update',
        //         data => array(
        //             array( symbol => 'XBTUSD', id => 8799284800, side => 'Sell', size => 721000 ),
        //             array( symbol => 'XBTUSD', id => 8799285100, side => 'Sell', size => 70590 ),
        //             array( symbol => 'XBTUSD', id => 8799285550, side => 'Sell', size => 217652 ),
        //             array( symbol => 'XBTUSD', id => 8799285850, side => 'Sell', size => 105578 ),
        //             array( symbol => 'XBTUSD', id => 8799286350, side => 'Sell', size => 172093 ),
        //             array( symbol => 'XBTUSD', id => 8799286650, side => 'Sell', size => 201125 ),
        //             array( symbol => 'XBTUSD', id => 8799288950, side => 'Buy', size => 47552 ),
        //             array( symbol => 'XBTUSD', id => 8799289250, side => 'Buy', size => 78217 ),
        //             array( symbol => 'XBTUSD', id => 8799289700, side => 'Buy', size => 193677 ),
        //             array( symbol => 'XBTUSD', id => 8799290000, side => 'Buy', size => 818161 ),
        //             array( symbol => 'XBTUSD', id => 8799290500, side => 'Buy', size => 218806 ),
        //             array( symbol => 'XBTUSD', id => 8799290800, side => 'Buy', size => 102946 )
        //         )
        //     }
        //
        if ($this->handle_error_message($client, $message)) {
            $table = $this->safe_string($message, 'table');
            $methods = array(
                'orderBookL2' => array($this, 'handle_order_book'),
                'orderBookL2_25' => array($this, 'handle_order_book'),
                'orderBook10' => array($this, 'handle_order_book'),
                'instrument' => array($this, 'handle_ticker'),
                'trade' => array($this, 'handle_trades'),
                'tradeBin1m' => array($this, 'handle_ohlcv'),
                'tradeBin5m' => array($this, 'handle_ohlcv'),
                'tradeBin1h' => array($this, 'handle_ohlcv'),
                'tradeBin1d' => array($this, 'handle_ohlcv'),
            );
            $method = $this->safe_value($methods, $table);
            if ($method === null) {
                return $message;
            } else {
                return $method($client, $message);
            }
        }
    }
}
